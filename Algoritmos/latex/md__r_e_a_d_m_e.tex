Bubble Sort\+: Este algoritmo compara cada elemento del arreglo con su vecino adyacente y los intercambia si están en orden incorrecto. Luego, se repite el proceso con cada par de elementos adyacentes hasta que no se realizan más intercambios. La complejidad temporal promedio y peor caso de este algoritmo es O(n$^\wedge$2), donde n es el número de elementos en el arreglo. Esto se debe a que el algoritmo debe iterar sobre el arreglo varias veces, y en cada iteración debe comparar y posiblemente intercambiar cada par de elementos adyacentes. Selection Sort\+: Este algoritmo busca el elemento más pequeño en el arreglo y lo intercambia con el primer elemento. Luego, busca el siguiente elemento más pequeño en el arreglo restante y lo intercambia con el segundo elemento, y así sucesivamente. La complejidad temporal promedio y peor caso de este algoritmo es O(n$^\wedge$2), donde n es el número de elementos en el arreglo. Esto se debe a que el algoritmo debe buscar el elemento más pequeño en el arreglo en cada iteración, y luego iterar sobre el arreglo restante para encontrar el siguiente elemento más pequeño. Insertion Sort\+: Este algoritmo divide el arreglo en dos partes\+: una parte ordenada y una parte no ordenada. Luego, toma cada elemento de la parte no ordenada y lo inserta en su posición correcta en la parte ordenada. La complejidad temporal promedio y peor caso de este algoritmo es O(n$^\wedge$2), donde n es el número de elementos en el arreglo. Esto se debe a que el algoritmo debe iterar sobre el arreglo varias veces y, en cada iteración, debe comparar y posiblemente mover cada elemento en la parte ordenada para hacer espacio para el elemento actual en la parte no ordenada. Quick Sort\+: Este algoritmo utiliza la estrategia \char`\"{}divide y conquista\char`\"{} para ordenar el arreglo. Primero, selecciona un elemento pivote del arreglo y divide el arreglo en dos partes\+: una parte con elementos menores que el pivote y otra parte con elementos mayores que el pivote. Luego, ordena cada parte recursivamente utilizando el mismo algoritmo. La complejidad temporal promedio de este algoritmo es O(n$\ast$log(n)), donde n es el número de elementos en el arreglo. Sin embargo, en el peor caso, cuando el pivote seleccionado siempre es el elemento más grande o más pequeño del arreglo, la complejidad temporal es O(n$^\wedge$2). Esto puede ocurrir si el arreglo está ordenado en orden ascendente o descendente y el pivote se selecciona como el primer o último elemento del arreglo.

Para compilar el programa, posicionarse en la carpeta llamada \char`\"{}\+Algoritmos\char`\"{} y utilizar el comando \char`\"{}make\char`\"{}. El ejecutable resultante se va a llamar Diosito1, proceda a ejecutar con la linea \char`\"{}./\+Diosito1\char`\"{}. Luego de eejcutar borre los ejecutables con el comando \char`\"{}make clean\char`\"{} para mayor orden y buen manejo de la memoria. 